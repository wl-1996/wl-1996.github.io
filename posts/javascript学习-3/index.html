<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>个人博客  | JavaScript学习-3</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.56.3" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.1cb140d8ba31d5b2f1114537dd04802a.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="JavaScript学习-3" />
<meta property="og:description" content="循环语句后续，函数等知识 for 循环里的 break语句 break语句的用途就是：我已经找到我要的答案了，我不需要进行更多的循环了的时候用。代码示例如下：
for(var i = 1; i&lt;=10; i&#43;&#43;){ console.log(i); if(i == 5){ break; //找到5，然后终止for循环。 } }  break语句只能中断最内层循环，外层循环还在继续，代码示例：
for(var i = 1; i&lt;=10; i&#43;&#43;){ for(var j = 1; j&lt;=10; j&#43;&#43;){ console.log(i,j) if(j == 5){ break; //当 j == 5 的时候，终止内层for循环，外层继续。 } } }  如果你就想用 break 终止外层的 for 循环，那么要给外层for循环加标签，代码示例：
waiceng : for(var i = 1; i&lt;=10; i&#43;&#43;){ for(var j = 1; j&lt;=10; j&#43;&#43;){ console.log(i,j) if(j == 5){ break waiceng; //此时中断的就是外层的for循环 } } }  上边的语法虽然有，但是工作中很少用到，非常偏门，了解即可。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://wangkuo.monster/posts/javascript%E5%AD%A6%E4%B9%A0-3/" />
<meta property="article:published_time" content="2019-12-09T09:24:23+08:00" />
<meta property="article:modified_time" content="2019-12-09T09:24:23+08:00" />
<meta itemprop="name" content="JavaScript学习-3">
<meta itemprop="description" content="循环语句后续，函数等知识 for 循环里的 break语句 break语句的用途就是：我已经找到我要的答案了，我不需要进行更多的循环了的时候用。代码示例如下：
for(var i = 1; i&lt;=10; i&#43;&#43;){ console.log(i); if(i == 5){ break; //找到5，然后终止for循环。 } }  break语句只能中断最内层循环，外层循环还在继续，代码示例：
for(var i = 1; i&lt;=10; i&#43;&#43;){ for(var j = 1; j&lt;=10; j&#43;&#43;){ console.log(i,j) if(j == 5){ break; //当 j == 5 的时候，终止内层for循环，外层继续。 } } }  如果你就想用 break 终止外层的 for 循环，那么要给外层for循环加标签，代码示例：
waiceng : for(var i = 1; i&lt;=10; i&#43;&#43;){ for(var j = 1; j&lt;=10; j&#43;&#43;){ console.log(i,j) if(j == 5){ break waiceng; //此时中断的就是外层的for循环 } } }  上边的语法虽然有，但是工作中很少用到，非常偏门，了解即可。">


<meta itemprop="datePublished" content="2019-12-09T09:24:23&#43;08:00" />
<meta itemprop="dateModified" content="2019-12-09T09:24:23&#43;08:00" />
<meta itemprop="wordCount" content="880">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="JavaScript学习-3"/>
<meta name="twitter:description" content="循环语句后续，函数等知识 for 循环里的 break语句 break语句的用途就是：我已经找到我要的答案了，我不需要进行更多的循环了的时候用。代码示例如下：
for(var i = 1; i&lt;=10; i&#43;&#43;){ console.log(i); if(i == 5){ break; //找到5，然后终止for循环。 } }  break语句只能中断最内层循环，外层循环还在继续，代码示例：
for(var i = 1; i&lt;=10; i&#43;&#43;){ for(var j = 1; j&lt;=10; j&#43;&#43;){ console.log(i,j) if(j == 5){ break; //当 j == 5 的时候，终止内层for循环，外层继续。 } } }  如果你就想用 break 终止外层的 for 循环，那么要给外层for循环加标签，代码示例：
waiceng : for(var i = 1; i&lt;=10; i&#43;&#43;){ for(var j = 1; j&lt;=10; j&#43;&#43;){ console.log(i,j) if(j == 5){ break waiceng; //此时中断的就是外层的for循环 } } }  上边的语法虽然有，但是工作中很少用到，非常偏门，了解即可。"/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="http://wangkuo.monster/" class="f3 fw2 hover-white no-underline white-90 dib">
      个人博客
    </a>
    <div class="flex-l items-center">
      

      
      














    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      




  <div id="sharing" class="mt3">

    
    <a href="https://www.facebook.com/sharer.php?u=http://wangkuo.monster/posts/javascript%E5%AD%A6%E4%B9%A0-3/" class="facebook no-underline" aria-label="share on Facebook">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

    </a>

    
    
    <a href="https://twitter.com/share?url=http://wangkuo.monster/posts/javascript%E5%AD%A6%E4%B9%A0-3/&amp;text=JavaScript%e5%ad%a6%e4%b9%a0-3" class="twitter no-underline" aria-label="share on Twitter">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

    </a>

    
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http://wangkuo.monster/posts/javascript%E5%AD%A6%E4%B9%A0-3/&amp;title=JavaScript%e5%ad%a6%e4%b9%a0-3" class="linkedin no-underline" aria-label="share on LinkedIn">
      <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

    </a>
  </div>

      <h1 class="f1 athelas mt3 mb1">JavaScript学习-3</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2019-12-09T09:24:23&#43;08:00">December 9, 2019</time>

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<h1 id="循环语句后续-函数等知识">循环语句后续，函数等知识</h1>

<h2 id="for-循环里的-break语句">for 循环里的 break语句</h2>

<p>break语句的用途就是：我已经找到我要的答案了，我不需要进行更多的循环了的时候用。代码示例如下：</p>

<pre><code class="language-javascript">for(var i = 1; i&lt;=10; i++){
    console.log(i);
    if(i == 5){
        break; //找到5，然后终止for循环。
    }
}
</code></pre>

<p>break语句只能中断最内层循环，外层循环还在继续，代码示例：</p>

<pre><code class="language-javascript">for(var i = 1; i&lt;=10; i++){
    for(var j = 1; j&lt;=10; j++){
        console.log(i,j)
        if(j == 5){
            break; //当 j == 5 的时候，终止内层for循环，外层继续。
        }
    }
}
</code></pre>

<p>如果你就想用 break 终止外层的 for 循环，那么要给外层for循环加标签，代码示例：</p>

<pre><code class="language-javascript">waiceng : for(var i = 1; i&lt;=10; i++){
    for(var j = 1; j&lt;=10; j++){
        console.log(i,j)
        if(j == 5){
            break waiceng; //此时中断的就是外层的for循环
        }
    }
}
</code></pre>

<p>上边的语法虽然有，但是工作中很少用到，非常偏门，了解即可。</p>

<h2 id="for-循环里的-continue-语句">for 循环里的 continue 语句</h2>

<p>continue 语句的用途就是：这个答案不是我想要的，赶紧试试下一个数字吧(遇见continue语句，for会立即终止执行continue后面的语句，然后立刻进行下一次迭代)。代码示例如下：</p>

<pre><code class="language-javascript">for(var i = 1; i&lt;=100; i++){
    if(i%5 == 0){
        continue;// 如果 i 能被5整除，那么就忽略下边的`console.log(i)`语句，继续下一个i的值。
    }
    console.log(i);
}
</code></pre>

<p>同样的，continue只能中断当前最内层的for循环，外层for要加label。</p>

<p>break 和 continue 整体的目的：优化算法。</p>

<p>用 continue 语句来寻找2-100(1不是质数)之内的所有质数：</p>

<pre><code class="language-javascript">// 原来的写法：
for(var i = 2; i&lt;=100; i++){
    var count = 0;
    for(var j = 1; j&lt;=i; j++ ){
        if(i%j == 0){
            count+=1;
        }
    }
    if(count == 2){
        console.log(i);
    }
}
</code></pre>

<pre><code class="language-javascript">// 用continue后的写法：
waiceng : for(var i = 2; i&lt;=100; i++){
    // 寻找2-100之间的所有质数，注意看与上边的不同，其中j从2开始，j&lt;i（这样就排除了 1 和 i本身两个数字）;
    for(var j =2; j&lt;i; j++){
        // 假如i为7，那么j的范围是2~6，也就是说在2~6之间，如果某个数j被i除尽了，说明这个数j就是i的约数，即i不是质数，此时用continue终止外层循环，进行下一次遍历
        if(i%j == 0){
            continue waiceng;
        }
    }
    console.log(i);// 上边的continue执行的话，就会忽略这个输出；上边的continue不执行的话才会有这个输出
}
</code></pre>

<p>上边的continue写法有一个地方还可以优化：</p>

<pre><code class="language-javascript">waiceng : for(var i = 2; i&lt;=100; i++){
    for(var j =2; j&lt;=Math.sqrt(i); j++){// 可以看到j&lt;=Math.sqrt(i),这个自己体会吧
        if(i%j == 0){
            continue waiceng;
        }
    }
    console.log(i);
}
</code></pre>

<h2 id="do-while-语句">do&hellip;while&hellip;语句</h2>

<h2 id="while-语句">while 语句</h2>

<p>踩地雷游戏：</p>

<pre><code class="language-javascript">// 随机生成一个地雷数字，范围是0~100，左闭右开
var dilei = parseInt(Math.random()*100)
// 声明上限和下限：
var xiaxian = 0
var shangxian = 100
while(true){
    var num = parseInt(prompt(&quot;请输入一个数字,范围是 &quot; + xiaxian + &quot;到&quot; + shangxian))
    if(num &gt; xiaxian &amp;&amp; num &lt;shangxian){
        // 根据用户输入的数字与地雷数的关系来调整上下限：
        if(num&lt;dilei){
            xiaxian = num
        }else if(num&gt;dilei){
            shangxian = num
        }else{
            alert(&quot;恭喜你，踩到地雷了&quot;)
            break
        }
    }else{
        alert(&quot;您输入的数字不在范围内，请重新输入&quot;)
    }
}
</code></pre>

<h2 id="随机数">随机数</h2>

<p><code>Math.random()</code>能够随机生成一个 0~1 的数字，包括0，不包括1。（但是shaoshanhuan说也不包括0），和<code>Math.pow();Math.sqrt()</code>一样都是<strong>Math对象</strong>的方法。</p>

<p><strong>公式：</strong>如果想要在[a,b]闭区间取随机整数，能取到a，也能取到b的话用下边的公式：</p>

<pre><code class="language-javascript">parseInt(Math.random()*(b - a + 1)) + a;
</code></pre>

<p>生成一个0-100的随机数：</p>

<pre><code class="language-javascript">// Math.random()生成一个 0~1 的数字，左闭右开（即包括0，不包括1）
var randomNum = parseInt(Math.random()*100)
console.log(randomNum)
</code></pre>

<h2 id="函数">函数</h2>

<h3 id="函数定义和调用">函数定义和调用</h3>

<p>语法：</p>

<pre><code class="language-javascript">// 函数定义
function 函数名(){

}
// 调用函数
函数名();
</code></pre>

<p>能够感觉到，函数是一些语句的集合。函数里的语句要么不出动，要么全出动。调用函数的时候才会出动。</p>

<p>在出现大量程序相同的时候，可以封装成一个function，这样只需要调用一次函数，就能执行函数里的很多语句。</p>

<p>我们在调用一个函数的时候，不用关心函数内部的实现细节，甚至这个函数是你上网抄的，可以运用。所以这个东西给我们团队开发带来了好处。</p>

<h3 id="函数的参数">函数的参数</h3>

<pre><code class="language-javascript">function sum(a,b){
    return a + b;
}
sum(3,8);
</code></pre>

<h3 id="函数的返回值">函数的返回值</h3>

<p>函数可以通过<strong>参数</strong>来接收东西，更可以通过 <strong>return</strong> 的语句来吐出东西。</p>

<pre><code class="language-javascript">function sum(a,b){
    return a+b;// 现在这个函数的返回值就是 a + b 的和
}
sum(3,8);// 此时调用了sum函数，但是不会在控制台输出 8 ，因为并没有一个输出语句
console.log(sum(3,8));// 这个语句才会在控制台输出 8。
// 这样理解：这个时候sum(3,8)是一个表达式，需要计算。
// 表达式的值是11，也就是说`console.log(11)`
</code></pre>

<p>函数有一个 return 的值，那么现在这个函数实际上就是一个<strong>表达式</strong>，换句话说这个函数就是一个值。<strong>所以这个函数可以当作其他函数的参数</strong>。代码示例：</p>

<pre><code class="language-javascript">function sum(a,b){
    return a+b;// 现在这个函数的返回值就是 a + b 的和
}
console.log(sum(3,sum(4,5)));// sum(4,5)是一个参数，这个参数的值为9，也就是说sum(4,5)这个函数调用当作了另一次sum调用函数的参数。
</code></pre>

<p>函数只能有<strong>唯一的</strong> return，有if语句除外，程序<strong>遇见了 return ，将立即返回结果，而不执行函数内剩余的程序</strong>。代码示例：</p>

<pre><code class="language-javascript">function fn(){
    console.log(1);
    console.log(2);
    return;// 函数返回一个空值，实际就是返回 undefined
    console.log(3);// 这行语句不执行，因为函数已经 return 了
}
fn(); // 此时只在控制台输出 1，2，不输出3。
</code></pre>

<h3 id="利用函数简化编程">利用函数简化编程</h3>

<p>声明一个函数，传入一个数字，返回这个数字的约数个数：</p>

<pre><code class="language-javascript">function yueshugeshu(n){
    var count = 0;
    for(var i = 1; i&lt;=n ; i++){
        if(n%i == 0){
            count++;
        }
    }
    return count;// 返回这个数字的约数的个数
}
</code></pre>

<p>再声明一个函数，传入一个数字，判断这个数字是否是质数（用到了上边的yueshugeshu函数）：</p>

<pre><code class="language-javascript">function isZhishu(m){
    if(yueshugeshu(m) == 2){// 如果 m 的约数个数是2，则返回 true
        return true;
    }else{
        return false;
    }
}
</code></pre>

<p>for 循环遍历1~100，找出所有的质数(用到了上边的两个函数)：</p>

<pre><code>for(var i = 1; i&lt;=100; i++){
    if(isZhishu(i)){
        console.log(i);
    }
}
</code></pre>

<p>哥德巴赫猜想：任何一个偶数，都可以拆分为两个质数的和(用到了上边的两个函数)</p>

<pre><code class="language-javascript">var oushu = parseInt(prompt(&quot;请输入一个偶数&quot;));
for(var i = 1; i &lt; oushu; i++){
    var j = oushu - i;
    if(isZhishu(i) &amp;&amp; isZhishu(j)){
      console.log(oushu + &quot; 可以拆分为 &quot; + i + &quot; 与 &quot; + j + &quot;  的和&quot;)
    }
}
</code></pre>

<p>遍历4~1000000之间的偶数，如果这个数能表示为两个质数的和，就输出这两个质数：</p>

<pre><code class="language-javascript">function yueshugeshu(n){
    var count = 0;
    for(var i = 1; i&lt;=n ; i++){
        if(n%i == 0){
            count++;
        }
    }
    return count;// 返回这个数字的约数的个数
}

function isZhishu(m){
    if(yueshugeshu(m) == 2){// 如果 m 的约数个数是2，则返回 true
        return true;
    }else{
        return false;
    }
}

waiceng : for(var i = 4;i&lt;=1000000; i+=2){
    for(var j = 2; j &lt; i; j++){
        var k = i - j;
        if(isZhishu(j) &amp;&amp; isZhishu(k)){
            console.log(i + &quot; 可以拆分为 &quot; + j + &quot;与&quot; + k + &quot; 的和&quot;);
            continue waiceng;// 如果拆成功了（也就是if里的语句执行了），那么continue就会忽略下边的continue语句，继续下一个i拆分；
        }
    }
    alert(&quot;哥德巴赫猜想失败&quot;);// 如果拆失败了，也即是if为false，这个时候if里的continue不会执行，那么这个alert语句就可以执行。
}
</code></pre>

<p>通过上边的哥德巴赫猜想可以看出：高层的业务，能使用底层的函数提供的API：</p>

<p><strong>约数个数函数 → 判断质数函数 → 高层业务</strong></p>

<p>小例子：计算1! + 2! + 3! + &hellip; +10! 的值</p>

<pre><code class="language-javascript">// 我自己写的这两个函数和调用，比老师讲的高级（老师第二个没封装函数，直接for循环了）

// 先声明阶乘函数，接受一个参数，返回这个数的阶乘： 
function jiecheng(n){
    var chengji = 1;
    for(var i = 1; i&lt;=n; i++){
        chengji *= i;
    }
    return chengji;
}


function qiuhe(n){
    var sum = 0;
    for(var i = 1; i&lt;=n ; i++){
        sum = sum + jiecheng(i);
    }
    return sum;
}

qiuhe(10);
</code></pre>

<p>考拉数计算：一个三位数，如果这个三位数的各位，十位，百位的阶乘加起来等于这个数本身，那么这个数就是考拉数。请找到100~999之间的一个考拉数：</p>

<pre><code class="language-javascript">function jiecheng(n){
    var chengji = 1;
    for(var i = 1; i&lt;=n; i++){
        chengji *= i;
    }
    return chengji;
}

for(var i = 100; i &lt;= 999; i++){
    var gewei = i % 10;
    var shiwei = parseInt(i/10)%10;
    var baiwei = parseInt(i/100);
    if(jiecheng(gewei) + jiecheng(shiwei) + jiecheng(baiwei) == i){
        console.log(i);
    }
}

</code></pre>

<h3 id="递归-函数自己调用自己就叫做递归">递归（函数自己调用自己就叫做递归）</h3>

<p>递归代码示例：</p>

<pre><code class="language-javascript">function haha(){
    console.log(&quot;哈哈&quot;);
    haha();// 函数自己调用了自己
}

haha();
</code></pre>

<p>斐波那契数列就是经典的递归算法：</p>

<p>1、1、2、3、5、8、13、21、34、55、89、144、233&hellip;</p>

<p>下边用编程实现输出斐波纳挈数列：</p>

<pre><code class="language-javascript">// 下边的代码会让浏览器崩溃，因为fib()函数会不断的递归调用自己，因为下边的for循环计算量太大了：
function fib(n){
    if(n == 1 || n == 2){
        return 1;
    }else{
        return fib(n -1) + fib(n - 2);
    }
}

for(var i = 1; i &lt;= 50; i++){
    console.log(fib(i));
}
</code></pre>

<h3 id="函数表达式">函数表达式</h3>

<p>定义函数除了使用 function 之外，还有一种方法就是函数表达式。就是函数没有名字，成为“<strong>匿名函数</strong>”，为了今后能调用它，我们把这个<strong>匿名函数</strong>，直接赋值给一个变量。</p>

<p>代码示例：</p>

<pre><code class="language-javascript">// 把匿名函数赋值给一个变量
var haha = function(a,b){
    return a + b;
}

// 调用的时候，可以直接使用 haha 变量来调用
console.log(haha(1,3));
</code></pre>

<h3 id="函数声明的提升">函数声明的提升</h3>

<p>JS在执行前，会有一个预解析的过程，把所有的函数声明，都提升到了最最开头，然后再执行第一行语句。代码示例：</p>

<pre><code class="language-javascript">// 在声明之前先调用函数
fn();

// 然后再定义函数：
function fn(){
    alert(&quot;我是函数，我执行了！&quot;);
}
</code></pre>

<p>上边的代码是先使用，后声明的，但是不会报错，因为函数声明提升到了最开头。</p>

<hr />

<p>函数声明能提升，但是<strong>函数表达式不能提升</strong>：</p>

<pre><code class="language-javascript">// 先调用
haha();

// 再声明
var haha = function(){
    alert(&quot;我是函数，我执行了！&quot;);
}
</code></pre>

<p><strong>上边的代码会报错，因为函数表达式不能提升。</strong></p>

<hr />

<p>上边的例子告诉我们，没有极特殊的理由，都要使用<code>function fn(){}</code>来定义函数，而不要使用函数表达式：<code>var haha = function(){}</code></p>

<hr />

<p>函数优先：如果同一个标识符，在程序中又是变量的名字，又是函数的名字，解析器会把标识符<strong>给函数</strong>！</p>

<pre><code class="language-javascript">aaa();// 这个 aaa 是函数

var aaa = 5;// 变量声明会提升（注意提升的是变量声明，变量的值不能提升），但是函数提升优先
function aaa(){
    alert(&quot;我是aaa函数，我执行了！&quot;);// 函数提升比变量声明提升优先
}
</code></pre>

<p>函数优先的另一个例子-这两个例子对照起来让我觉得不好理解（这是shaoshanhuan第五天讲的，我补到这里了）</p>

<pre><code class="language-javascript">var a = 1;
function a(){
    alert(&quot;我是函数&quot;);
}

a();// 此时会报错，系统认为 a 是一个变量
</code></pre>

<p>在执行 <code>var a = 1</code> 之前，函数已经把 <code>function a()</code>预解析了，程序就知道页面上有一个函数叫做 a 。但是开始执行程序之后，定义了一个变量 a ,所以标识符 a 就又变成变量了。接下来遇见 function 定义，程序会无视，因为已经预解析了。直到 a() 运行的时候，a 就是变量，无法运行，报错。</p>

<h3 id="函数是一个引用类型">函数是一个引用类型</h3>

<p>我们之前说的，基本类型：number string boolean undefined null。引用类型也有很多种：object function array RegExp Math Date。</p>

<pre><code class="language-javascript">function fn(){

}
console.log(typeof fn);// 输出 function
</code></pre>

<p>函数也是一种类型，这个类型就叫做 function，是引用类型的一种。</p>

<hr />

<p><strong>基本类型保存值，引用类型保存地址。</strong></p>

<pre><code class="language-javascript">var a = 1;
var b = a;// b得到的值，是a的副本。a把自己的值赋值了一份，给了b
b = 3; // 更改了b的值，a不受影响
console.log(a);
</code></pre>

<p>我们现在变量 a = 6; 那么这个 a 变量里面存储的是 6 这个数值。而 a = function(){} 那么这个 a 标签里面存储的是 function 的内存地址。代码示例：</p>

<pre><code class="language-javascript">// 定义了一个变量 a ，引用了一个匿名函数。这个 a 变量里存储的是这个匿名函数的内存地址：
var a = function(){
    alert(&quot;我是一个函数，我执行了&quot;);
}
var b = a;// 把匿名函数的地址也给了 b

b.haha = 1;// 给 b 添加一个属性
console.log(a.haha);// 输出1，你会发现和 b 的哈哈属性值相同
b.haha++;
b.haha++;
b.haha++;
console.log(a.haha); //输出4，b一变，a也跟着变；因为 a 和 b 都是指向的同一个对象
</code></pre>

<hr />
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://wangkuo.monster/" >
    &copy;  个人博客 2020 
  </a>
    <div>













</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
