<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>个人学习博客  | 小总结</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.56.3" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.1cb140d8ba31d5b2f1114537dd04802a.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="小总结" />
<meta property="og:description" content="什么是闭包？闭包的用途是什么？闭包的缺点是什么？ 什么是闭包： 如果一个函数用到了外部的变量，那么这个函数加这个变量就叫做闭包，代码示例如下：
function f1() { let a = 2; function f2() { console.log(a); } }  上边的函数 f2 用到了外部的变量 a，函数 f2 加上变量 a 就叫做闭包。
闭包的用途： 闭包的用途很多，最大用途有两个：第一是从外部读取局部变量，第二是让这些变量的值始终保持在内存中。下边详细解释这两种用途：
用途 1：从外部读取局部变量 代码示例：
function f1() { let n = 110; function f2() { alert(n); } }  在上面的代码中，函数 f2 被包括在函数 f1 内部，这时 f1 内部的所有局部变量，对 f2 都是可见的。但是反过来不行，函数 f2 的局部变量，对 f1 就是不可见的。
那么问题来了，既然 f2 可以读取 f1 中的局部变量，那么只要把 f2 作为返回值，我们不就可以在 f1 外部读取它的内部变量了么？这样就解决了之前在函数外部无法读取函数内的局部变量的问题。 代码示例：
function f1() { let n = 110; function f2() { alert(n); } return f2; } let haha = f1(); //调用f1函数，返回f2函数的引用给哈哈 haha(); //调用haha也就是调用了f2，弹出110  用途 2：让局部变量的值始终保持在内存中 代码示例：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://wangkuo.monster/posts/%E5%B0%8F%E6%80%BB%E7%BB%93/" />
<meta property="article:published_time" content="2019-12-25T11:51:29+08:00" />
<meta property="article:modified_time" content="2019-12-25T11:51:29+08:00" />
<meta itemprop="name" content="小总结">
<meta itemprop="description" content="什么是闭包？闭包的用途是什么？闭包的缺点是什么？ 什么是闭包： 如果一个函数用到了外部的变量，那么这个函数加这个变量就叫做闭包，代码示例如下：
function f1() { let a = 2; function f2() { console.log(a); } }  上边的函数 f2 用到了外部的变量 a，函数 f2 加上变量 a 就叫做闭包。
闭包的用途： 闭包的用途很多，最大用途有两个：第一是从外部读取局部变量，第二是让这些变量的值始终保持在内存中。下边详细解释这两种用途：
用途 1：从外部读取局部变量 代码示例：
function f1() { let n = 110; function f2() { alert(n); } }  在上面的代码中，函数 f2 被包括在函数 f1 内部，这时 f1 内部的所有局部变量，对 f2 都是可见的。但是反过来不行，函数 f2 的局部变量，对 f1 就是不可见的。
那么问题来了，既然 f2 可以读取 f1 中的局部变量，那么只要把 f2 作为返回值，我们不就可以在 f1 外部读取它的内部变量了么？这样就解决了之前在函数外部无法读取函数内的局部变量的问题。 代码示例：
function f1() { let n = 110; function f2() { alert(n); } return f2; } let haha = f1(); //调用f1函数，返回f2函数的引用给哈哈 haha(); //调用haha也就是调用了f2，弹出110  用途 2：让局部变量的值始终保持在内存中 代码示例：">


<meta itemprop="datePublished" content="2019-12-25T11:51:29&#43;08:00" />
<meta itemprop="dateModified" content="2019-12-25T11:51:29&#43;08:00" />
<meta itemprop="wordCount" content="1850">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="小总结"/>
<meta name="twitter:description" content="什么是闭包？闭包的用途是什么？闭包的缺点是什么？ 什么是闭包： 如果一个函数用到了外部的变量，那么这个函数加这个变量就叫做闭包，代码示例如下：
function f1() { let a = 2; function f2() { console.log(a); } }  上边的函数 f2 用到了外部的变量 a，函数 f2 加上变量 a 就叫做闭包。
闭包的用途： 闭包的用途很多，最大用途有两个：第一是从外部读取局部变量，第二是让这些变量的值始终保持在内存中。下边详细解释这两种用途：
用途 1：从外部读取局部变量 代码示例：
function f1() { let n = 110; function f2() { alert(n); } }  在上面的代码中，函数 f2 被包括在函数 f1 内部，这时 f1 内部的所有局部变量，对 f2 都是可见的。但是反过来不行，函数 f2 的局部变量，对 f1 就是不可见的。
那么问题来了，既然 f2 可以读取 f1 中的局部变量，那么只要把 f2 作为返回值，我们不就可以在 f1 外部读取它的内部变量了么？这样就解决了之前在函数外部无法读取函数内的局部变量的问题。 代码示例：
function f1() { let n = 110; function f2() { alert(n); } return f2; } let haha = f1(); //调用f1函数，返回f2函数的引用给哈哈 haha(); //调用haha也就是调用了f2，弹出110  用途 2：让局部变量的值始终保持在内存中 代码示例："/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="http://wangkuo.monster/" class="f3 fw2 hover-white no-underline white-90 dib">
      个人学习博客
    </a>
    <div class="flex-l items-center">
      

      
      














    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      




  <div id="sharing" class="mt3">

    
    <a href="https://www.facebook.com/sharer.php?u=http://wangkuo.monster/posts/%E5%B0%8F%E6%80%BB%E7%BB%93/" class="facebook no-underline" aria-label="share on Facebook">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

    </a>

    
    
    <a href="https://twitter.com/share?url=http://wangkuo.monster/posts/%E5%B0%8F%E6%80%BB%E7%BB%93/&amp;text=%e5%b0%8f%e6%80%bb%e7%bb%93" class="twitter no-underline" aria-label="share on Twitter">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

    </a>

    
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http://wangkuo.monster/posts/%E5%B0%8F%E6%80%BB%E7%BB%93/&amp;title=%e5%b0%8f%e6%80%bb%e7%bb%93" class="linkedin no-underline" aria-label="share on LinkedIn">
      <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

    </a>
  </div>

      <h1 class="f1 athelas mt3 mb1">小总结</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2019-12-25T11:51:29&#43;08:00">December 25, 2019</time>

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<h2 id="什么是闭包-闭包的用途是什么-闭包的缺点是什么">什么是闭包？闭包的用途是什么？闭包的缺点是什么？</h2>

<h3 id="什么是闭包">什么是闭包：</h3>

<p>如果一个函数用到了外部的变量，那么这个函数加这个变量就叫做闭包，代码示例如下：</p>

<pre><code class="language-javascript">function f1() {
  let a = 2;
  function f2() {
    console.log(a);
  }
}
</code></pre>

<p>上边的函数 f2 用到了外部的变量 a，函数 f2 加上变量 a 就叫做闭包。</p>

<hr />

<hr />

<h3 id="闭包的用途">闭包的用途：</h3>

<p>闭包的用途很多，最大用途有两个：第一是从外部读取局部变量，第二是让这些变量的值始终保持在内存中。下边详细解释这两种用途：</p>

<p>用途 1：从外部读取局部变量 代码示例：</p>

<pre><code class="language-javascript">function f1() {
  let n = 110;

  function f2() {
    alert(n);
  }
}
</code></pre>

<p>在上面的代码中，函数 f2 被包括在函数 f1 内部，这时 f1 内部的所有局部变量，对 f2 都是可见的。但是反过来不行，函数 f2 的局部变量，对 f1 就是不可见的。</p>

<p>那么问题来了，既然 f2 可以读取 f1 中的局部变量，那么只要把 f2 作为返回值，我们不就可以在 f1 外部读取它的内部变量了么？这样就解决了之前在函数外部无法读取函数内的局部变量的问题。 代码示例：</p>

<pre><code class="language-javascript">function f1() {
  let n = 110;
  function f2() {
    alert(n);
  }
  return f2;
}

let haha = f1(); //调用f1函数，返回f2函数的引用给哈哈
haha(); //调用haha也就是调用了f2，弹出110
</code></pre>

<hr />

<p>用途 2：让局部变量的值始终保持在内存中 代码示例：</p>

<pre><code class="language-javascript">function f1() {
  let n = 110;
  // 第一：add 前面没有使用 var 关键字，因此 add 是一个全局变量
  // 第二：add本身也是一个闭包
  add = function() {
    n += 1;
  };
  function f2() {
    alert(n);
  }
  return f2;
}

let haha = f1(); //调用f1函数，返回f2的引用给哈哈
haha(); //调用haha，等价于调用了f2函数 弹出110

add(); //调用add函数，使得n加1
haha(); //弹出111
</code></pre>

<p>在这段代码中，haha 实际上就是闭包 f2 函数。它一共运行了两次，第一次的值是 110，第二次的值是 111。这证明了，函数 f1 中的局部变量 n 一直保存在内存中，并没有在 f1 调用后被自动清除。</p>

<p>为什么会这样呢？原因就在于 f1 是 f2 的父函数，而 f2 被赋给了一个全局变量 haha，这导致 f2 始终在内存中，而 f2 的存在依赖于 f1，因此 f1 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>

<p>这段代码中另一个值得注意的地方，就是<code>add=function(){n+=1}</code>这一行，首先在 add 前面没有使用 var 关键字，因此 add 是一个<strong>全局变量</strong>，而不是局部变量。其次，add 的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以 add 相当于是一个 setter，可以在函数外部对函数内部的局部变量进行操作。</p>

<hr />

<hr />

<h3 id="闭包的缺点">闭包的缺点：</h3>

<p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致<strong>内存泄露</strong>。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>

<p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>

<h3 id="关键点">关键点</h3>

<p>关键点一 ：什么是闭包：——「函数使用了外部的变量」</p>

<p>关键点二 ：用途：——「隐藏局部变量，暴露操作函数」</p>

<pre><code class="language-javascript">const createAdd = () =&gt; {
  let n = 0;
  // 返回一个箭头函数
  return () =&gt; {
    n += 1;
    console.log(n);
  };
};

const add = createAdd(); //调用createAdd函数，返回一个箭头函数给add
add(); //调用箭头函数 输出1
add(); //调用箭头函数 输出2
</code></pre>

<p>关键点三：缺点：——「容易内存泄露」。注意，虽然闭包并不会造成内存泄露，真实原因是 JS 引擎的实现有问题，但网上已经以讹传讹了。所以注意这一点。</p>

<h2 id="call-apply-bind-的用法分别是什么">call、apply、bind 的用法分别是什么？</h2>

<h3 id="call-apply-的功能相同-都是为了绑定-this-代码示例">call,apply 的功能相同，都是为了绑定 this，代码示例：</h3>

<pre><code class="language-javascript">let obj = {
  name: &quot;树懒&quot;,
  age: 16,
  sex: &quot;男&quot;
};
// 声明一个函数，用来显示名字
function showName() {
  alert(this.name);
}
// 调用函数：
showName.call(obj); //用call语法调用showName函数，并且传入this为obj对象。那么就会弹出obj对象的名字属性：树懒
showName.apply(obj); //此时跟apply的效果一样，也会弹出：树懒
</code></pre>

<p>从上边的代码示例可以看出，apply、call 功能是一样的，功能都是：让函数调用，并且给函数设置 this 是谁。</p>

<hr />

<h3 id="但是-apply-call-的语法不同-代码示例如下">但是 apply、call 的语法不同，代码示例如下：</h3>

<pre><code class="language-javascript">let obj = {
  name: &quot;王阔&quot;,
  age: 23,
  sex: &quot;男&quot;
};

function showInformation(a, b, c) {
  console.log(this.name);
  console.log(a + b + c);
}

// 用call语法和apply语法分别调用函数，传入的参数形式不同，但是实际相同：
showInformation.call(obj, 1, 2, 3); //会弹出 王阔 ,和 6
showInformation.apply(obj, [1, 2, 3]); //同样弹出 王阔 ,和 6
</code></pre>

<p>从上例可以看出，用 call 语法和 apply 语法分别调用函数时，showName 函数里面的 this 就是 obj 对象。但是我们发现，showName 这个函数，有别的参数。那么我们现在又想设置 this 是谁，又想传入别的参数，此时两种语法就有区别了：</p>

<p>call 语法：</p>

<pre><code class="language-javascript">fn.call(obj,参数1,参数2,参数3...)
</code></pre>

<p>apply 语法：</p>

<pre><code class="language-javascript">fn.apply(obj,[参数1,参数2,参数3...])
</code></pre>

<p>也就是说：call 需要你用逗号罗列所有参数，但是 apply 是把所有参数写到一个数组里面。<strong>即使只有一个参数，也必须写在数组里面：</strong></p>

<pre><code class="language-javascript">let obj = {
  name: &quot;王阔&quot;,
  age: 23,
  sex: &quot;男&quot;
};

function showInformation(n) {
  for (let i = 0; i &lt; n; i++) {
    console.log(this.name);
  }
}

showInformation.call(obj, 10); //打印 10 次 王阔
console.log(&quot;哈哈&quot;);
showInformation.apply(obj, [10]); //打印 10 次 王阔
</code></pre>

<hr />

<h3 id="bind-的用法-绑定-this">bind 的用法：绑定 this</h3>

<p>使用 .bind 可以让 this 不被改变，代码示例：</p>

<pre><code class="language-javascript">function f1(p1, p2) {
  console.log(this, p1, p2);
}
let f2 = f1.bind({ name: &quot;wangkuo&quot; });
// 那么f2就是f1绑定了this之后的新函数：
f2(); //等价于 f1.call({name:&quot;wangkuo&quot;})
</code></pre>

<p>.bind 还可以绑定其他参数，代码示例：</p>

<pre><code class="language-javascript">let f3 = f1.bind({ name: &quot;wangkuo&quot; }, &quot;hi&quot;, &quot;ha&quot;); //f1.bind()返回一个新函数，新函数绑定了this和其它参数
f3(); //等价于f1.call({name:&quot;wangkuo},&quot;hi&quot;,&quot;ha&quot;)
</code></pre>

<h3 id="关键点-1">关键点</h3>

<p>call 的第一个参数是 this，后面的参数是 arguments 或其他参数</p>

<p>apply 的第二个参数必须是数组，内含所有其他参数</p>

<p>bind 的用法要有两点:</p>

<ol>
<li>fn.bind(x,y,z) 不会执行 fn，而是会返回一个新的函数</li>
<li>新的函数执行时，会调用 fn，调用形式为 fn.call(x, y, z)，其中 x 是 this，y 和 z 是其他参数</li>
</ol>

<h2 id="http-状态码-并描述各状态码的意义">HTTP 状态码，并描述各状态码的意义。</h2>

<p>HTTP 状态码分为五类：信息响应（100-199），成功响应（200-299），重定向（300-399），客户端错误（400-499）和服务器错误（500-599）。这里简要介绍以下 10 个状态码：</p>

<ol>
<li>100 表示迄今为止的所有内容都是可行的，客户端应该继续请求；</li>
<li>101 该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议；</li>
<li>200 表示请求成功，通常表示服务器提供了请求的网页；</li>
<li>201 表示请求已成功，并因此创建了一个新的资源。这通常是在 POST 请求，或是在某些 PUT 请求之后返回的响应；</li>
<li>202 表示请求已经收到，但还未响应，没有结果；</li>
<li>203 表示服务器已经成功处理了请求，但返回的信息来自本地或者第三方的拷贝；</li>
<li>204 服务器成功处理了请求，但没有返回任何内容；</li>
<li>205 服务器成功处理了请求，并且没有返回任何内容。但是和 204 响应不同，返回此状态码的响应要求请求者重置文档视图。</li>
<li>206 表示服务器成功处理了部分 GET 请求；</li>
<li>300 表示被请求的资源有很多选择，每个选择都有特定的地址，用户能够根据需要自行选择一个地址进行重定向；</li>
<li>301 表示被请求的资源已经永久移动到新的位置。服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置；</li>
<li>307 表示服务器目前临时从不同位置的网页响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求；</li>
<li>400 表示语义有误或者请求参数有误，当前请求无法被服务器理解；</li>
<li>401 表示当前请求需要用户验证。对于需要登录的网页，服务器可能返回此响应；</li>
<li>403 表示服务器已经理解请求，但是拒绝执行它；</li>
<li>404 表示请求失败，在服务器上没有找到请求对应的资源；</li>
<li>408 表示请求超时。客户端可以再次提交这一请求而无需进行任何更改；</li>
<li>410 表示请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这种状况应当被认为是永久性的；</li>
<li>500 表示服务器遇到了不知道如何处理的情况；</li>
<li>501 表示此请求方法不被服务器支持且无法被处理。只有 GET 和 HEAD 是要求服务器支持的，它们必定不会返回此错误代码。</li>
<li>503 表示服务器没有准备好处理请求。常见原因是服务器因维护或重载而停机，通常，这只是暂时状态；</li>
</ol>

<h3 id="关键点-2">关键点：</h3>

<p>答案见维基百科：<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#2xx.E6.88.90.E5.8A.9F">https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#2xx.E6.88.90.E5.8A.9F</a></p>

<h2 id="数组去重">数组去重：</h2>

<p>如何实现数组去重？
假设有数组 array = [1,5,2,3,4,2,3,1,3,4],你要写一个函数 unique，使得 unique(array) 的值为 [1,5,2,3,4]也就是把重复的值都去掉，只保留不重复的值。</p>

<h3 id="不使用-set-实现">不使用 Set 实现</h3>

<pre><code class="language-javascript">// 使用for嵌套for，然后splice去重（ES5中最常用）
// splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。
function unique(arr) {
  for (let i = 0; i &lt; arr.length; i++) {
    for (let j = i + 1; j &lt; arr.length; j++) {
      if (arr[i] == arr[j]) {
        //假设第一个等同于第二个，就用splice方法删除第二个
        arr.splice(j, 1); //假如arr是[1,1,2,1]，此时i和j的值都是1，就把下标为j的元素删除，删除后arr变为了[1,2,1]
        j--; //上边arr变为了[1,2,1]，少了一个元素，下标j就带减1才能取到2
      }
    }
  }
  return arr;
}

let arr = [1, 1, &quot;true&quot;, &quot;true&quot;, true, true, 15,
    15, false, false, undefined, undefined, null,
    null, NaN, NaN, &quot;NaN&quot;, 0, 0, &quot;a&quot;, &quot;a&quot;, {}, {}];
console.log(unique(arr)); //输出 [1, &quot;true&quot;, 15, false, undefined, NaN, NaN, &quot;NaN&quot;, &quot;a&quot;, {…}, {…}]
</code></pre>

<p>双层循环，外层循环元素，内层循环时比较值。外层内层值相同时，则删去内层这个值。</p>

<p>缺点：<strong>NaN 和{}没有去重，两个 null 直接消失了</strong></p>

<hr />

<h3 id="使用-set">使用 Set</h3>

<pre><code class="language-javascript">// 利用Set去重（ES6中最常用）
function unique(arr) {
  return Array.from(new Set(arr));
  // 或者 return [...new Set(arr)]
}

let arr = [1, 1, &quot;true&quot;, &quot;true&quot;, true, true, 15,
    15, false, false, undefined, undefined, null,
    null, NaN, NaN, &quot;NaN&quot;, 0, 0, &quot;a&quot;, &quot;a&quot;, {}, {}];

console.log(unique(arr)); //输出：[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, {…}, {…}]
</code></pre>

<p>不考虑兼容性，这种去重的方法代码最少。</p>

<p>缺点：API 太新，旧浏览器不支持。并且<strong>无法去掉“{}”空对象</strong>。</p>

<hr />

<h3 id="使用了-map-weakmap-以支持对象去重的">使用了 Map / WeakMap 以支持对象去重的</h3>

<pre><code class="language-javascript">// 使用Map数据结构去重：
function unique(arr) {
  let map = new Map();
  let array = new Array(); //数组用于返回结果
  for (let i = 0; i &lt; arr.length; i++) {
    if (map.has(arr[i])) {
      // 判断 hashMap 中是否已有该 key 值
      map.set(arr[i], true); //后面的true 代表该 key 值在原始数组中重复了，false反之
    } else {
      // 如果 hashMap 中没有该 key 值，添加该key值到array
      map.set(arr[i], false);
      array.push(arr[i]);
    }
  }
  return array;
}

let arr = [1, 1, &quot;true&quot;, &quot;true&quot;, true, true, 15,
    15, false, false, undefined, undefined, null,
    null, NaN, NaN, &quot;NaN&quot;, 0, 0, &quot;a&quot;, &quot;a&quot;, {}, {}];
console.log(unique(arr)); //输出  [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, {…}, {…}]
</code></pre>

<p>创建一个空 Map 数据结构，遍历需要去重的数组，把数组的每一个元素作为 key 存到 Map 中。由于 Map 中不会出现相同的 key 值，所以最终得到的就是去重后的结果。</p>

<p>缺点：API 太新，旧浏览器不支持。并且<strong>无法去掉“{}”空对象</strong>。</p>

<h3 id="关键点-3">关键点：</h3>

<p>不使用 Set，借鉴计数排序的原理</p>

<pre><code class="language-javascript">unique = array =&gt; {
  const hash = [];
  for (let i = 0; i &lt; array.length; i++) {
    hash[array[i]] = true;
  }
  const result = [];
  for (let k in hash) {
    result.push(k);
  }
  return result;
};
</code></pre>

<p>方案一缺点：只支持数字或者字符串数组，如果数组里面有对象，比如 array = [{number:1}, 2]，就会出错。</p>

<p>接下来使用 Set:</p>

<pre><code class="language-javascript">unique = array =&gt; {
  return [...new Set(array)];
  // 或者 return Array.from(new Set(array))
};
</code></pre>

<p>方案二缺点：API 太新，旧浏览器不支持。</p>

<p>接下来使用 Map:</p>

<pre><code class="language-javascript">unique = array =&gt; {
  let map = new Map();
  let result = [];
  for (let i = 0; i &lt; array.length; i++) {
    if (map.has(array[i])) {
      // 判断 map 中是否已有该 key
      continue;
    } else {
      // 如果 map 中没有该 key，就加入 result 中
      map.set(array[i], true);
      result.push(array[i]);
    }
  }
  return result;
};
</code></pre>

<p>方案三缺点：API 太新，旧浏览器不支持。</p>

<h2 id="dom-事件相关">DOM 事件相关：</h2>

<h3 id="1-什么是事件委托">1.什么是事件委托？</h3>

<p>事件委托还有一个名字叫事件代理，JavaScript 高级程序设计上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。那这是什么意思呢？网上的各位大牛们讲事件委托基本上都用了同一个例子，就是<strong>取快递</strong>来解释这个现象：</p>

<p>有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台 MM 代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台 MM 收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台 MM 也会在收到寄给新员工的快递后核实并代为签收。</p>

<p>这里其实还有 2 层意思：</p>

<p>第一，现在委托前台的同事是可以代为签收的，即程序中的现有的 dom 节点是有事件的；</p>

<p>第二，新员工也是可以被前台 MM 代为签收的，即程序中新添加的 dom 节点也是有事件的。</p>

<hr />

<hr />

<h3 id="2-怎么阻止默认动作">2.怎么阻止默认动作？</h3>

<p>w3c 的方法是 e.preventDefault(),IE 则是使用 e.returnValue = false;</p>

<p>preventDefault 它是事件对象(Event)的一个方法，作用是取消一个目标元素的默认行为。既然是说默认行为，当然是元素必须有默认行为才能被取消，如果元素本身就没有默认行为，调用当然就无效了。什么元素有默认行为呢？如链接<code>&lt;a&gt;</code>，提交按钮<code>&lt;input type=”submit”&gt;</code>等。当 Event 对象的 cancelable 为 false 时，表示没有默认行为，这时即使有默认行为，调用 preventDefault 也是不会起作用的。</p>

<p>我们都知道，链接<code>&lt;a&gt;</code>的默认动作就是跳转到指定页面，下面就以它为例，阻止它的跳转：</p>

<pre><code class="language-javascript">&lt;a href=&quot;https://www.baidu.com&quot; id=&quot;baiduLink&quot;&gt;
  baidu.com
&lt;/a&gt;;

let baiduLink = document.getElementById(&quot;baiduLink&quot;);
baiduLink.onclick = function(e) {
  if (e.preventDefault) {
    // w3c的方法：
    e.preventDefault();
  } else {
    //IE的写法：
    window.event.returnValue == false;
  }
};
</code></pre>

<hr />

<hr />

<h3 id="3-怎么阻止事件冒泡">3.怎么阻止事件冒泡？</h3>

<p>什么是事件冒泡？</p>

<p>如果一个按钮是绑定一个”click”事件，那么”click”事件会依次在它的父级元素中被触发 。</p>

<pre><code class="language-javascript">&lt;div id=&quot;div&quot;&gt;
  &lt;ul id=&quot;ul&quot;&gt;
    &lt;li id=&quot;li&quot;&gt;test&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
&lt;script&gt;
  let div = document.getElementById(&quot;div&quot;);
  let ul = document.getElementById(&quot;ul&quot;);
  let li = document.getElementById(&quot;li&quot;)
  div.onclick = () =&gt; {
    alert(&quot;div&quot;);
  };
  ul.onclick = () =&gt; {
    alert(&quot;ul&quot;);
  };
  li.onclick = () =&gt; {
    alert(&quot;li&quot;);
  };
&lt;/script&gt;
</code></pre>

<p>上面的代码,我们单击 test 时，会依次触发 alert(“li”),alert(“ul”),alert(“div”)，这就是事件冒泡。</p>

<hr />

<p>那么怎么阻止事件冒泡呢？</p>

<p>w3c 的方法是 e.stopPropagation(),IE 则是使用 e.cancelBubble = true</p>

<p>上边的 demo 阻止冒泡可以在 li 的点击事件里加上这一句代码：</p>

<pre><code class="language-javascript">window.event ? (window.event.cancelBubble = true) : e.stopPropagation();
</code></pre>

<h3 id="关键点-4">关键点</h3>

<p>事件委托：不监听元素 C 自身，而是监听其祖先元素 P，然后判断 e.target 是不是该元素 C（或该元素的子元素）</p>

<p>阻止默认动作：e.preventDefault() 或者 return false</p>

<p>阻止冒泡：e.stopPropagation()</p>

<h2 id="如何理解-js-的继承">如何理解 JS 的继承？</h2>

<h3 id="1-基于原型的继承">1. 基于原型的继承</h3>

<p>当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私有属性（称之为 __proto__ ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( __proto__ ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。</p>

<p>几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。</p>

<p>JavaScript 对象有一个指向一个原型对象的链。<strong>当试图访问一个对象的属性时</strong>，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，<strong>依次层层向上搜索</strong>，直到找到一个名字匹配的属性或到达原型链的末尾。</p>

<p>这里演示当尝试访问属性时会发生什么？</p>

<pre><code class="language-javascript">let f = function() {
  this.a = 1;
  this.b = 2;
};

let o = new f();

//在f函数的原型上定义属性：
f.prototype.b = 3;
f.prototype.c = 4;

// 不要在 f 函数的原型上直接定义 f.prototype = {b:3,c:4};这样会直接打破原型链
// o.[[Prototype]] 有属性 b 和 c
//  (其实就是 o.\_\_proto\_\_ 或者 o.constructor.prototype)
// o.[[Prototype]].[[Prototype]] 是 Object.prototype.
// 最后o.[[Prototype]].[[Prototype]].[[Prototype]]是null
// 这就是原型链的末尾，即 null，
// 根据定义，null 就是没有 [[Prototype]]

// 综上，整个原型链如下:

// {a:1, b:2} ---&gt; {b:3, c:4} ---&gt; Object.prototype---&gt; null

console.log(o.a); // a是o的自身属性吗？是的，该属性的值为 1
console.log(o.b);
// b是o的自身属性吗？是的，该属性的值为 2
// 原型上也有一个'b'属性，但是它不会被访问到。
// 这种情况被称为&quot;属性遮蔽 (property shadowing)&quot;
console.log(o.c);
// c是o的自身属性吗？不是，那看看它的原型上有没有
// c是o.[[Prototype]]的属性吗？是的，该属性的值为 4
console.log(o.d);
// d 是 o 的自身属性吗？不是，那看看它的原型上有没有
// d 是 o.[[Prototype]] 的属性吗？不是，那看看它的原型上有没有
// d 是 o.[[Prototype]].[[Prototype]] 的属性吗？不是，那看看它的原型上有没有
// o.[[Prototype]].[[Prototype]].[[Prototype]] 为 null ，停止搜索
// 找不到 d 属性，返回 undefined
</code></pre>

<h3 id="2-基于-class-的继承">2. 基于 class 的继承</h3>

<h3 id="关键点-5">关键点：</h3>

<p>注意：继承这题里面基于 class 的继承没看到有相关说明，然后基于原型的继承感觉像在说原型链。</p>

<p>基于原型：</p>

<pre><code class="language-javascript">function Parent(name1) {
  this.name1 = name1;
}
Parent.prototype.pMethod = function() {
  console.log(this.name1);
};

function Child(name2, name1) {
  Parent.call(this, name1); // 得分点
  this.name2 = name2;
}
Child.prototype.__proto__ = Parent.prototype;
//上面这句代码的古板写法应该是下面三句
//const empty = function(){}
//empty.prototype = Parent.prototype
//Child.prototype = new empty()
//古板写法额外加两分

Child.prototype.cMethod = function() {
  console.log(this.name2);
};

//如果写成下面这种，就扣两分
//Child.prototype = {
//    cMethod: function(){
//        console.log(this.name2)
//    }
//}
</code></pre>

<p>基于 class：</p>

<pre><code class="language-javascript">class Parent {
  constructor(name1) {
    this.name1 = name1;
  }
  pMethod() {
    console.log(this.name1);
  }
}
class Child extends Parent {
  constructor(name2, name1) {
    super(name1); // 得分点
    this.name2 = name2;
  }
  cMethod() {
    console.log(this.name2);
  }
}
</code></pre>

<h2 id="数组排序">数组排序</h2>

<p>给出正整数数组 array = [2,1,5,3,8,4,9,5]，请写出一个函数 sort，使得 sort(array) 得到从小到大排好序的数组 [1,2,3,4,5,5,8,9]。新的数组可以是在 array 自身上改的，也可以是完全新开辟的内存。</p>

<h3 id="选择排序的循环写法">选择排序的循环写法：</h3>

<pre><code class="language-javascript">// 思路：从numbers的第一个元素开始遍历，
// 每次遍历时找到最小的元素，然后将这个最小元素与当前遍历的元素交换位置，以此循环。
// 这样就能每次把最小的元素提到最前边，从而完成排序
let sort = numbers =&gt; {
  for (let i = 0; i &lt; numbers.length - 1; i++) {
    let index = minIndex(numbers.slice(i)) + i;
    if (index !== i) {
      swap(numbers, index, i);
    }
  }
  return numbers;
};
// 声明minIndex函数，作用是返回一个数组中最小元素的下标
let minIndex = array =&gt; {
  let index = 0;
  for (let i = 1; i &lt; array.length; i++) {
    if (array[i] &lt; array[index]) {
      index = i;
    }
  }
  return index;
};
// 声明swap函数，作用是将一个数组中下标为i和j的元素交换位置
let swap = (array, i, j) =&gt; {
  let temp = array[i];
  array[i] = array[j];
  array[j] = temp;
};
// 调用函数sort，将数组进行排序
sort([2, 1, 5, 3, 8, 4, 9, 5]);
</code></pre>

<h2 id="你对-promise-的了解">你对 Promise 的了解？</h2>

<h3 id="1-promise-的用途">1. Promise 的用途</h3>

<p>为了解决“异步任务有两个结果（成功或者失败）的问题”</p>

<p>传统解决方法有两种：1.回调接受两个参数； 2.搞两个回调；</p>

<p>但是这两种传统解决方法都不可避免的存在一些问题：</p>

<ol>
<li><p>不规范，名称五花八门，有人用 success+error，有人用 success+fail，有人用 done+fail；</p></li>

<li><p>容易出现回调地狱，让代码变得看不懂；</p></li>

<li><p>很难进行错误处理；</p></li>
</ol>

<p><strong>为了更好的解决这两个问题，Promise 应运而生。</strong></p>

<hr />

<h3 id="2-如何创建一个-new-promise">2. 如何创建一个 new Promise</h3>

<pre><code class="language-javascript">return new Promise((resolve, reject) =&gt; {});
</code></pre>

<p>完整代码：</p>

<pre><code class="language-javascript">ajax = (method, url, options) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    //析构赋值，相当于：const success = options.success;const fail = options.fail;
    const { success, fail } = options;
    const request = new XMLHttpRequest(); //创建对象
    request.open(method, url); //调用open方法
    //监听对象的 onreadystatechange 事件：
    request.onreadystatechange = () =&gt; {
      if (request.readyState === 4) {
        //成功就调用 resolve,失败就调用reject
        if (request.status &lt; 400) {
          resolve.call(null, request.response);
        } else if (request.status &gt;= 400) {
          reject.call(null, request);
        }
      }
    };
    request.send(); //发送请求
  });
};

ajax(&quot;get&quot;, &quot;/xxx&quot;).then(
  response =&gt; {},
  (request, status) =&gt; {}
);
</code></pre>

<hr />

<h3 id="3-如何使用-promise-prototype-then">3. 如何使用 Promise.prototype.then</h3>

<p>then()方法返回一个 Promise。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。</p>

<p>使用 then 方法：</p>

<pre><code class="language-javascript">var p1 = new Promise((resolve, reject) =&gt; {
  resolve(&quot;成功&quot;);
  // or
  // reject(new Error(&quot;出错了！&quot;));
});

p1.then(
  value =&gt; {
    console.log(value); //成功！
  },
  reason =&gt; {
    console.error(reason); //出错!
  }
);
</code></pre>

<hr />

<h3 id="4-如何使用-promise-all">4. 如何使用 Promise.all</h3>

<p>Promise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中 promise 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 promise 的结果。</p>

<p>Promise.all 的使用：</p>

<pre><code class="language-javascript">var p1 = Promise.resolve(3);
var p2 = 1337;
var p3 = new Promise((resolve, reject) =&gt; {
  setTimeout(resolve, 100, &quot;foo&quot;);
});

Promise.all([p1, p2, p3]).then(values =&gt; {
  console.log(values); // [3, 1337, &quot;foo&quot;]
});
</code></pre>

<hr />

<h3 id="5-如何使用-promise-race">5. 如何使用 Promise.race</h3>

<p>Promise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。</p>

<p>Promise.race 的用法示例:</p>

<pre><code class="language-javascript">var promise1 = new Promise(function(resolve, reject) {
  setTimeout(resolve, 500, &quot;one&quot;);
});

var promise2 = new Promise(function(resolve, reject) {
  setTimeout(resolve, 100, &quot;two&quot;);
});

Promise.race([promise1, promise2]).then(function(value) {
  console.log(value);
  // 都处理了，但是 promise2 更快
});
// 输出： &quot;two&quot;
</code></pre>

<h3 id="关键点-6">关键点：</h3>

<p>要点零：</p>

<p>Promise 用于避免回调地域，让代码看起来更同步</p>

<p>要点一：</p>

<pre><code class="language-javascript">function fn(){
    return new Promise((resolve, reject)=&gt;{
        成功时调用 resolve(data)
        失败时调用 reject(reason)
    })
}
</code></pre>

<p>要点二：const promise1 = fn() // 得到 promise1 对象</p>

<p>fn().then(success, fail).then(success2, fail2).catch(fail3)</p>

<p>或者 promise1.then(success, fail).then(success2, fail2).catch(fail3)均可</p>

<p>要点三：Promise.all([promise1, promise2]) 并行，等待所有 promise 成功。</p>

<p>如果都成功了，则 all 对应的 promise 也成功；如果有一个失败了，则 all 对应的 promise 失败。</p>

<p>要点四：Promise.race([promise1, promise2])，返回一个 promise，一旦数组中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。</p>

<h2 id="跨域">跨域：</h2>

<h3 id="1-什么是同源">1. 什么是同源</h3>

<p>如果两个 url 的：协议、域名、端口号 完全一致，那么这两个 url 就是同源的。</p>

<p>例如：</p>

<p><a href="https://qq.com">https://qq.com</a> 和 <a href="https://www.baidu.com">https://www.baidu.com</a> 不同源；</p>

<p><a href="https://baidu.com">https://baidu.com</a> 和 <a href="https://www.baidu.com">https://www.baidu.com</a> 不同源；</p>

<h3 id="2-什么是跨域">2. 什么是跨域</h3>

<p>一个网站获取另外一个不同源网站的数据就叫做跨域。</p>

<p>定义：跨域是指从一个域名的网页去请求另一个域名的资源。比如从 www.baidu.com 页面去请求 www.google.com 的资源。跨域的严格一点的定义是：只要 协议，域名，端口有任何一个的不同，就被当作是跨域。</p>

<h3 id="3-jsonp-跨域">3. JSONP 跨域</h3>

<p>JSONP 是 JSON with Padding（填充式 json）的简写，是应用 JSON 的一种新方法，只不过是被包含在函数调用中的 JSON，例如：<code>callback({&quot;name&quot;:&quot;trigkit4})</code></p>

<p>JSONP 由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的 JSON 数据。</p>

<p>JSONP 的原理：通过 script 标签引入一个 js 文件，这个 js 文件载入成功后会执行我们在 url 参数中指定的函数，并且会把我们需要的 json 数据作为参数传入。所以 jsonp 是需要服务器端的页面进行相应的配合的。（即用 javascript 动态加载一个 script 文件，同时定义一个 callback 函数给 script 执行而已。）</p>

<p>在 js 中，我们直接用 XMLHttpRequest 请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的 js 脚本文件却是可以的，jsonp 正是利用这个特性来实现的。</p>

<h3 id="4-cors-跨域">4. CORS 跨域</h3>

<p>CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。</p>

<p>服务器端对于 CORS 的支持，主要就是通过设置 <code>Access-Control-Allow-Origin</code> 来进行的。如果浏览器检测到相应的设置，就可以允许 Ajax 进行跨域的访问。只需要在后台中加上响应头来允许域请求！在被请求的 Response header 中加入以下设置，就可以实现跨域访问了！</p>

<p>代码示例：</p>

<pre><code class="language-javascript">//指定允许其他域名访问
&quot;Access-Control-Allow-Origin:*&quot;; //或指定域
//响应类型
&quot;Access-Control-Allow-Methods:GET,POST&quot;;
//响应头设置
&quot;Access-Control-Allow-Headers:x-requested-with,content-type&quot;;
</code></pre>

<h2 id="我对前端的理解">我对前端的理解：</h2>

<p>通过这几个月的学习，我觉得前端就是指网站的前台部分，用户能直接看得见的部分。包括网站的表现层和结构层：Web 页面的结构、Web 页面的外观、Web 页面的交互。</p>

<p>而前端要呈现在用户面前，又需要前端设计和前端开发两个部分。前端设计我理解就是网站的视觉设计，样式设计；前端开发则是将设计出来的网页通过代码实现出来。</p>

<p>前端开发我觉得又分为三类：</p>

<p><strong>1. Web 前端开发：HTML+CSS+Javascript</strong></p>

<p>HTML（超文本标记语言——HyperText Markup Language）定义了网页内容的含义和结构。</p>

<p>CSS (层叠样式表-Cascading Style Sheets），是一种 样式表 语言，用来描述 HTML 或 XML（包括如 SVG、MathML、XHTML 之类的 XML 分支语言）文档的呈现。CSS 描述了在屏幕、纸质、音频等其它媒体上的元素应该如何被渲染的问题。</p>

<p>JavaScript ( JS ) 是一种编程语言。是运行在浏览器上的一种脚本语言，负责页面的交互。</p>

<p><strong>2. Android 终端开发：Java</strong></p>

<p><strong>3. iOS 终端开发：Objective-C</strong></p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://wangkuo.monster/" >
    &copy;  个人学习博客 2020 
  </a>
    <div>













</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
